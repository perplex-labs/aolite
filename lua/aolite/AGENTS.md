### Title

**AOLite â€” Local Agent-Oriented Simulation Toolkit (`lua/aolite`)**

---

### Overview

AOLite embeds the **AO runtime** inside a single Lua VM so tests or back-tests can create many processes, queue messages, reorder queues, and drive a deterministic coroutine-based scheduler â€” **all without Arweave / Bundlr or a real network**.

---

### Key Data Structures & Fields

| Structure                     | Origin                            | Core Fields / Notes                                                                                                                                                                                                                |
| ----------------------------- | --------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`LocalAOEnv`**              | `env.lua`                         | `processes{}` per-PID â‡’ `{process, ao, Handlers, env}` Â· `queues{}` inbound msg IDs Â· `coroutines{}` running loops Â· `messageStore{}` global msg table Â· `ready{}` set of PIDs with work Â· flags `autoSchedule`, `messageLogPath`. |
| **Process descriptor**        | `process.spawnProcess`            | Holds previously mentioned four objects plus on-boot coroutine.                                                                                                                                                                    |
| **Global Outbox record**      | generated by `ao.send / ao.spawn` | `Messages[]`, `Spawns[]`, `Assignments[]`, `Output {}`; flushed by `process.deliverOutbox`.                                                                                                                                        |
| **Message format (internal)** | built in `ao.send`                | `Id = From:Reference`, `From`, `Target`, `Action`, `Data`, `Tags[]`, `Timestamp`, helpers `onReply/receive` (closures).                                                                                                            |

---

### Key Functions

| Function                                         | File                  | Purpose & Key Params                                                                                                                                           |
| ------------------------------------------------ | --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`process.spawnProcess(pid, source, tags)`**    | `process.lua`         | Builds Handlers + AO + Process wrapper; sets dedicated sandbox via custom `require`; registers main coroutine; loads source (string, module or `On-Boot` tag). |
| **`process.send(env,msg,from)`**                 | `process.lua`         | Standardises fields, inserts into target queue, logs.                                                                                                          |
| **`process.deliverOutbox(env, pid, pushedFor)`** | `process.lua`         | Flushes AO outbox into global queues; converts `Spawns`, handles assignments.                                                                                  |
| **`api.send(env,msg,clearInbox)`**               | `api.lua`             | User front-end: routes through `ao.send`, then `process.send`; optionally wipes sender inbox.                                                                  |
| **`api.get{First,Last,All}Msg`**                 | `api.lua`             | Convenience fetch (auto-runs scheduler if `env.autoSchedule`).                                                                                                 |
| **`api.eval(env,pid,expr)`**                     | `api.lua`             | Injects `EvalRequest`; waits for `EvalResponse`; JSON-deserialises result.                                                                                     |
| **`scheduler.run(env,maxCycles)`**               | `scheduler.lua`       | Round-robin resumes coroutines whose PIDs are in `env.ready`, up to `maxCycles`.                                                                               |
| **`main.*` exported helpers**                    | `main.lua`            | Thin wrappers around API + scheduler for tests (`spawnProcess`, `send`, `getLastMsg`, etc.)                                                                    |
| **`compat.lua`** (`require` hijack)              | replaces `_G.require` | Maps friendly aliases (`ao`, `.bint`, `.crypto.*`) to concrete paths; allows second arg `processEnv` to load chunk into process sandbox.                       |
| **`eval_exp.eval(expr)`**                        | safe eval             | Compiles/pcalls expression inside isolated env; returns `(success,resultOrErr)`.                                                                               |
| **`eval.lua` Handlers**                          | adds to every process | `_eval` (interactive REPL) & `EvalRequestHandler` (JSON-serialize return value).                                                                               |

---

### Relationships / Data Flow

* **`main.lua` âžœ API âžœ process âžœ ao runtime**
  `main.spawnProcess` â‡’ `process.spawnProcess` â‡’ `createAO`, `createHandlers`, `createProcess` (from *ao* dir).
  Messages sent via `main.send` â†’ `api.send` â†’ `process.send` â†’ target queue.

* **Scheduler** drives coroutines; each resume:

  1. flush sender outbox (`deliverOutbox`)
  2. pop one queued msg; call `processModule.handle` (AO runtime, described in `AGENTS.md` for `ao/`).

* **Eval pipeline**: `api.eval` ðŸ¡’ `EvalRequest` â†’ process handler in `eval.lua` ðŸ¡’ run expression via `eval_exp` ðŸ¡’ reply `EvalResponse` JSON.

* **Compatibility layer** ensures user code written for *on-chain* paths (`require("ao")`, `require(".log")`) still load locally.

---

### Usage Flow (typical test)

1. `local ao = require("aolite")` (loads `main.lua`).
2. `ao.spawnProcess("p1", "my.module", { {name="On-Boot",value="Data"} })`
3. `ao.send{ From="p1", Target="p1", Action="Ping" }` *(auto-scheduler runs unless disabled)*
4. Inspect with `ao.getLastMsg("p1",{ Action="Pong" })`.
5. Pause auto-scheduling via `ao.setAutoSchedule(false)`, queue many messages, reorder queue with `ao.reorderQueue`, then `ao.runScheduler()`.
6. Evaluate arbitrary code inside a process: `ao.eval("p1","return 2+2") â†’ 4`.
7. Log every wire message by `ao.setMessageLog("./msg.log")`.

---

### File-by-File Summary

| File                | Primary APIs / Logic                                                                                            |
| ------------------- | --------------------------------------------------------------------------------------------------------------- |
| **`api.lua`**       | send wrapper, eval helper, message fetch helpers.                                                               |
| **`compat.lua`**    | Global `require` shim & module aliasing (e.g., `"ao"` â†’ `aolite.ao.ao`).                                        |
| **`env.lua`**       | `LocalAOEnv.new()` creates shared simulation state containers.                                                  |
| **`eval_exp.lua`**  | Pure expression evaluator used by handlers.                                                                     |
| **`eval.lua`**      | Registers `_eval` + `EvalRequest` handlers into every process; serializes results via `lib.serialize`.          |
| **`process.lua`**   | Heavy-weight orchestration: spawnProcess, send/deliverOutbox, per-process coroutine loop, message logging.      |
| **`scheduler.lua`** | Simple cooperative scheduler that runs ready coroutines until queues drain or `maxCycles` exceeded.             |
| **`main.lua`**      | Public faÃ§ade imported by examples/tests; exposes spawn/send/query/scheduler controls; manages singleton `env`. |

---

### Notable Constants & Conventions

* **Reference tag** (`Reference`) must exist on every outbound msg; `ao.send` auto-generates monotonic counter per process.
* **Anchor** is 32-char zero-padded string of same counter for replay determinism.
* **`autoSchedule` flag** (env) toggles implicit scheduler run after every `ao.send`.
* **Queues** store **message IDs only**; real message bodies live in `env.messageStore` allowing aliasing by assignment.
* **In-process `require(module, processEnv)`** (second arg) triggers sandboxed chunk load to keep globals isolated.

The documentation above enables another LLM to reconstruct the full in-memory simulation pipeline, implement additional utilities, or generate tests that leverage AOLiteâ€™s local AO environment.
